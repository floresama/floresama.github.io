<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üéÆ Juegos de Amor - Para Mavi üéÆ</title>
    <link rel="stylesheet" href="/estilos/style.css">
    <link rel="stylesheet" href="/estilos/actividades.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta2/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=New+Amsterdam&display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="./imagenes/linux.png" type="">
</head>
<body class="fondo">

    <!-- Part√≠culas flotantes -->
    <div class="floating-particles" id="particles"></div>

    <header class="encabezado"> 
        <nav class="main-navbar">
            <img src="/imagenes/bellaka.jpeg" alt="" class="logoPrincipal">
            <ul class="menu">
                <li><a class="nav-item" href="index.html"><strong>Inicio</strong></a></li>
                <li><a class="nav-item" href="actividades_de_amor.html"><strong>Juegos de Amor</strong></a></li>      
                <li><a class="nav-item" href="collage.html"><strong>Collage</strong></a></li>                  
            </ul>
        </nav>
    </header>

    <!-- Men√∫ Principal de Juegos -->
    <div id="mainMenu" class="games-menu">
        <div class="menu-title">
            <h1>üéÆ Juegos de Amor para Mavi üéÆ</h1>
            <p class="menu-subtitle">Elige el juego que m√°s te guste para jugar juntos</p>
        </div>

        <div class="games-grid">
            <div class="game-option" onclick="showGame('puzzle')">
                <div class="game-icon">üß©</div>
                <h3>üß© Puzzle Rom√°ntico</h3>
                <p>Arma rompecabezas con nuestras fotos de amor</p>
                <div class="game-difficulty">
                    <span class="difficulty-label">Dificultad:</span>
                    <span class="difficulty-stars">‚≠ê‚≠ê‚≠ê</span>
                </div>
            </div>

            <div class="game-option" onclick="showGame('archery')">
                <div class="game-icon">üèπ</div>
                <h3>üèπ Tiro al Blanco del Amor</h3>
                <p>Dispara flechas a corazones y gana puntos</p>
                <div class="game-difficulty">
                    <span class="difficulty-label">Dificultad:</span>
                    <span class="difficulty-stars">‚≠ê‚≠ê</span>
                </div>
            </div>
        </div>

        <div class="menu-footer">
            <p>üíï Cada juego es una nueva aventura de amor üíï</p>
        </div>
    </div>

    <!-- Juego del Puzzle -->
    <div id="puzzleGame" class="game-container" style="display: none;">
        <div class="game-header">
            <button class="back-btn" onclick="showMainMenu()">‚Üê Volver al Men√∫</button>
            <div class="game-stats">
                <span>‚è±Ô∏è Tiempo: <span id="puzzleTime">00:00</span></span>
                <span>üéØ Movimientos: <span id="puzzleMoves">0</span></span>
                <span>üèÜ Nivel: <span id="puzzleLevel">1</span></span>
            </div>
        </div>

        <div class="puzzle-container">
            <div class="puzzle-info">
                <h2>üß© Puzzle Rom√°ntico</h2>
                <p>Arma la imagen de amor seleccionando el nivel de dificultad</p>
                <div class="difficulty-selector">
                    <button class="diff-btn active" data-difficulty="3" data-photo="1">3x3 - Foto 1</button>
                    <button class="diff-btn" data-difficulty="4" data-photo="2">4x4 - Foto 2</button>
                    <button class="diff-btn" data-difficulty="5" data-photo="3">5x5 - Foto 3</button>
                </div>
                <button id="startPuzzleBtn" class="start-btn">üöÄ Iniciar Puzzle</button>
                <button id="debugBtn" class="debug-btn" onclick="if(puzzleGame) puzzleGame.testImages()">üêõ Debug Im√°genes</button>
                <button id="resetBtn" class="reset-btn" onclick="if(puzzleGame) puzzleGame.resetGame()">üîÑ Reset Puzzle</button>
            </div>
            <div id="puzzleBoard" class="puzzle-board">
                <div id="puzzleStatus" class="puzzle-status">
                    <p>Selecciona la dificultad y haz clic en "Iniciar Puzzle" para comenzar</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Juego de Tiro al Blanco -->
    <div id="archeryGame" class="game-container" style="display: none;">
        <div class="game-header">
            <button class="back-btn" onclick="showMainMenu()">‚Üê Volver al Men√∫</button>
            <div class="game-stats">
                <span>üéØ Puntos: <span id="archeryScore">0</span></span>
                <span>üèπ Flechas: <span id="archeryArrows">10</span></span>
                <span>‚ù§Ô∏è Vidas: <span id="archeryLives">3</span></span>
            </div>
        </div>

        <div class="archery-container">
            <div class="archery-info">
                <h2>üèπ Tiro al Blanco del Amor</h2>
                <p>Dispara flechas a los corazones para ganar puntos</p>
                <button id="startArcheryBtn" class="start-btn">üöÄ Iniciar Juego</button>
            </div>
            <canvas id="archeryCanvas" width="800" height="600"></canvas>
            <div class="archery-controls">
                <p>üéÆ Usa el mouse para apuntar y hacer click para disparar</p>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let currentGame = null;
        let puzzleGame = null;
        let archeryGame = null;

        // Mostrar men√∫ principal
        function showMainMenu() {
            document.getElementById('mainMenu').style.display = 'block';
            document.getElementById('puzzleGame').style.display = 'none';
            document.getElementById('archeryGame').style.display = 'none';
            
            if (puzzleGame) puzzleGame.stop();
            if (archeryGame) archeryGame.stop();
            
            currentGame = null;
        }

        // Mostrar juego espec√≠fico
        function showGame(gameType) {
            document.getElementById('mainMenu').style.display = 'none';
            currentGame = gameType;

            if (gameType === 'puzzle') {
                document.getElementById('puzzleGame').style.display = 'block';
                if (!puzzleGame) {
                    puzzleGame = new PuzzleGame();
                }
            } else if (gameType === 'archery') {
                document.getElementById('archeryGame').style.display = 'block';
                if (!archeryGame) {
                    archeryGame = new ArcheryGame();
                }
            }
        }

        // Clase del Juego del Puzzle
        class PuzzleGame {
            constructor() {
                this.difficulty = 3;
                this.currentPhoto = 1;
                this.pieces = [];
                this.moves = 0;
                this.startTime = null;
                this.timer = null;
                this.isPlaying = false;
                this.puzzleImage = null;
                this.draggedPiece = null;
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                
                console.log('üîß Constructor de PuzzleGame ejecutado');
                this.setupEventListeners();
                
                // Probar im√°genes al crear la instancia
                setTimeout(() => {
                    this.testImages();
                }, 1000);
            }

            setupEventListeners() {
                document.getElementById('startPuzzleBtn').addEventListener('click', () => this.startGame());
                
                document.querySelectorAll('.diff-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.difficulty = parseInt(e.target.dataset.difficulty);
                        this.currentPhoto = parseInt(e.target.dataset.photo);
                    });
                });
            }

            startGame() {
                // Verificar que no haya un juego en curso
                if (this.isPlaying) {
                    return;
                }
                
                this.isPlaying = true;
                this.moves = 0;
                this.startTime = Date.now();
                this.updateStats();
                
                // Limpiar el tablero antes de cargar nueva imagen
                const board = document.getElementById('puzzleBoard');
                board.innerHTML = '';
                
                // Timeout de seguridad para evitar que la p√°gina se congele
                const safetyTimeout = setTimeout(() => {
                    if (this.isPlaying && this.pieces.length === 0) {
                        console.error('‚ö†Ô∏è Timeout de seguridad: El juego no se inici√≥ en 10 segundos');
                        this.showStatus('‚ö†Ô∏è Timeout de seguridad. Haz clic en "Reset Puzzle" e intenta de nuevo.');
                        this.isPlaying = false;
                    }
                }, 10000);
                
                this.loadPuzzleImage();
                
                // Limpiar timeout cuando se complete
                this.onGameStarted = () => {
                    clearTimeout(safetyTimeout);
                };
            }

            loadPuzzleImage() {
                const photoMap = {
                    1: './imagenes/pg1.jpeg',
                    2: './imagenes/pg2.jpeg',
                    3: './imagenes/pg3.jpeg',
                    4: './imagenes/pg4.jpeg',
                    5: './imagenes/pg5.jpeg'
                };

                console.log('=== DEBUGGING IMAGEN ===');
                console.log('Foto seleccionada:', this.currentPhoto);
                console.log('Ruta de la imagen:', photoMap[this.currentPhoto]);
                console.log('Ruta completa:', window.location.href);

                // Mostrar mensaje de carga
                this.showStatus('üîÑ Cargando imagen del puzzle...');

                // Intentar con diferentes rutas
                const pathsToTry = [
                    photoMap[this.currentPhoto], // Ruta relativa
                    photoMap[this.currentPhoto].replace('./', '/'), // Ruta desde ra√≠z
                    window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '/') + photoMap[this.currentPhoto].substring(2), // Ruta absoluta
                    photoMap[this.currentPhoto].replace('./', '../') // Ruta relativa hacia arriba
                ];

                console.log('Rutas a probar:', pathsToTry);

                this.tryLoadImage(pathsToTry, 0);
            }

            tryLoadImage(paths, index) {
                if (index >= paths.length) {
                    console.error('‚ùå Todas las rutas fallaron');
                    this.showStatus('‚ùå No se pudo cargar la imagen con ninguna ruta');
                    this.showRetryButton();
                    return;
                }

                const path = paths[index];
                console.log(`Intentando ruta ${index + 1}/${paths.length}: ${path}`);

                this.puzzleImage = new Image();
                
                this.puzzleImage.onload = () => {
                    console.log('‚úÖ Imagen cargada correctamente con ruta:', this.puzzleImage.src);
                    console.log('Dimensiones de la imagen:', this.puzzleImage.width, 'x', this.puzzleImage.height);
                    this.showStatus('‚úÖ Imagen cargada correctamente');
                    setTimeout(() => {
                        this.createBoard();
                    }, 500);
                };
                
                this.puzzleImage.onerror = (error) => {
                    console.error(`‚ùå Error con ruta ${path}:`, error);
                    // Intentar siguiente ruta
                    setTimeout(() => {
                        this.tryLoadImage(paths, index + 1);
                    }, 100);
                };
                
                this.puzzleImage.src = path;
            }

            showRetryButton() {
                const board = document.getElementById('puzzleBoard');
                const retryBtn = document.createElement('button');
                retryBtn.className = 'retry-btn';
                retryBtn.textContent = 'üîÑ Reintentar';
                retryBtn.onclick = () => this.loadPuzzleImage();
                board.appendChild(retryBtn);
            }

            resetGame() {
                console.log('üîÑ Reseteando el juego...');
                
                // Detener el juego actual
                this.isPlaying = false;
                this.stopTimer();
                
                // Limpiar el tablero
                const board = document.getElementById('puzzleBoard');
                if (board) {
                    board.innerHTML = '';
                }
                
                // Resetear variables
                this.pieces = [];
                this.moves = 0;
                this.startTime = null;
                this.draggedPiece = null;
                this.isDragging = false;
                
                // Mostrar mensaje de estado
                this.showStatus('üîÑ Juego reseteado. Selecciona la dificultad y haz clic en "Iniciar Puzzle" para comenzar.');
                
                // Actualizar estad√≠sticas
                this.updateStats();
                
                console.log('‚úÖ Juego reseteado correctamente');
            }

            showStatus(message) {
                const board = document.getElementById('puzzleBoard');
                const statusElement = document.getElementById('puzzleStatus');
                
                if (statusElement) {
                    statusElement.innerHTML = `<p>${message}</p>`;
                } else {
                    const newStatus = document.createElement('div');
                    newStatus.id = 'puzzleStatus';
                    newStatus.className = 'puzzle-status';
                    newStatus.innerHTML = `<p>${message}</p>`;
                    board.appendChild(newStatus);
                }
            }

            // M√©todo para probar si las im√°genes existen
            testImages() {
                console.log('=== PROBANDO IM√ÅGENES ===');
                console.log('URL actual:', window.location.href);
                console.log('Directorio actual:', window.location.pathname);
                
                const photoMap = {
                    1: './imagenes/pg1.jpeg',
                    2: './imagenes/pg2.jpeg',
                    3: './imagenes/pg3.jpeg',
                    4: './imagenes/pg4.jpeg',
                    5: './imagenes/pg5.jpeg'
                };
                
                Object.entries(photoMap).forEach(([key, path]) => {
                    const img = new Image();
                    img.onload = () => {
                        console.log(`‚úÖ Imagen ${key} (${path}) cargada correctamente`);
                        console.log(`   Dimensiones: ${img.width} x ${img.height}`);
                        console.log(`   URL completa: ${img.src}`);
                    };
                    img.onerror = (error) => {
                        console.error(`‚ùå Imagen ${key} (${path}) NO se pudo cargar`);
                        console.error(`   Error:`, error);
                        
                        // Intentar con ruta absoluta
                        const absolutePath = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '/') + path.substring(2);
                        console.log(`   Intentando con ruta absoluta: ${absolutePath}`);
                        
                        const img2 = new Image();
                        img2.onload = () => {
                            console.log(`‚úÖ Imagen ${key} cargada con ruta absoluta: ${absolutePath}`);
                        };
                        img2.onerror = () => {
                            console.error(`‚ùå Imagen ${key} tampoco se pudo cargar con ruta absoluta`);
                        };
                        img2.src = absolutePath;
                    };
                    img.src = path;
                });
                
                // Mostrar estado actual
                this.showDebugInfo();
            }

            showDebugInfo() {
                console.log('=== ESTADO ACTUAL DEL PUZZLE ===');
                console.log('Dificultad:', this.difficulty);
                console.log('Foto actual:', this.currentPhoto);
                console.log('Jugando:', this.isPlaying);
                console.log('Imagen del puzzle:', this.puzzleImage);
                console.log('Piezas creadas:', this.pieces.length);
                
                const board = document.getElementById('puzzleBoard');
                if (board) {
                    console.log('Tablero encontrado:', board);
                    console.log('Contenido del tablero:', board.innerHTML);
                    console.log('Estilos del tablero:', board.style.cssText);
                } else {
                    console.error('‚ùå Tablero no encontrado');
                }
            }

            createBoard() {
                try {
                    console.log('=== CREANDO TABLERO ===');
                    console.log('Imagen disponible:', this.puzzleImage);
                    console.log('Imagen completa:', this.puzzleImage?.complete);
                    console.log('Imagen naturalWidth:', this.puzzleImage?.naturalWidth);
                    console.log('Imagen naturalHeight:', this.puzzleImage?.naturalHeight);
                    
                    // Verificar que la imagen est√© disponible
                    if (!this.puzzleImage || !this.puzzleImage.complete) {
                        console.error('‚ùå La imagen del puzzle no est√° disponible');
                        this.showStatus('‚ùå Error: La imagen no se carg√≥ correctamente');
                        return;
                    }
                    
                    console.log('‚úÖ Imagen verificada, creando tablero...');
                    
                    const board = document.getElementById('puzzleBoard');
                    if (!board) {
                        console.error('‚ùå Tablero no encontrado');
                        return;
                    }
                    board.innerHTML = '';
                    this.pieces = [];
                
                // Limpiar mensaje de estado
                const statusElement = document.getElementById('puzzleStatus');
                if (statusElement) {
                    statusElement.remove();
                }
                
                // Crear el tablero visual
                board.style.width = '400px';
                board.style.height = '400px';
                board.style.position = 'relative';
                board.style.border = '3px solid rgba(255, 105, 180, 0.5)';
                board.style.borderRadius = '15px';
                board.style.overflow = 'hidden';
                
                const pieceSize = 400 / this.difficulty;
                
                // Crear piezas del puzzle
                console.log('Creando', this.difficulty * this.difficulty, 'piezas del puzzle...');
                
                for (let row = 0; row < this.difficulty; row++) {
                    for (let col = 0; col < this.difficulty; col++) {
                        const piece = document.createElement('div');
                        piece.className = 'puzzle-piece';
                        piece.style.position = 'absolute';
                        piece.style.width = pieceSize + 'px';
                        piece.style.height = pieceSize + 'px';
                        piece.style.cursor = 'grab';
                        piece.style.border = '2px solid rgba(255, 105, 180, 0.8)';
                        piece.style.borderRadius = '8px';
                        piece.style.overflow = 'hidden';
                        piece.style.transition = 'box-shadow 0.3s ease';
                        
                        // Posici√≥n correcta de la pieza
                        const correctX = col * pieceSize;
                        const correctY = row * pieceSize;
                        
                        // Posici√≥n inicial aleatoria usando el m√©todo mejorado
                        const randomPos = this.generateRandomPosition(pieceSize);
                        piece.style.left = randomPos.x + 'px';
                        piece.style.top = randomPos.y + 'px';
                        
                        // Configurar imagen de fondo
                        const imageUrl = this.puzzleImage.src;
                        console.log(`Pieza [${row},${col}]: URL imagen = ${imageUrl}`);
                        console.log(`Pieza [${row},${col}]: Posici√≥n imagen = -${correctX}px -${correctY}px`);
                        
                        piece.style.backgroundImage = `url(${imageUrl})`;
                        piece.style.backgroundSize = `${400}px ${400}px`;
                        piece.style.backgroundPosition = `-${correctX}px -${correctY}px`;
                        piece.style.backgroundRepeat = 'no-repeat';
                        
                        // Datos de la pieza
                        piece.dataset.correctX = correctX;
                        piece.dataset.correctY = correctY;
                        piece.dataset.currentX = randomPos.x;
                        piece.dataset.currentY = randomPos.y;
                        piece.dataset.row = row;
                        piece.dataset.col = col;
                        
                        // Eventos de drag and drop
                        piece.addEventListener('mousedown', (e) => this.startDrag(e, piece));
                        
                        board.appendChild(piece);
                        this.pieces.push(piece);
                        
                        console.log(`Pieza [${row},${col}] creada y agregada al tablero`);
                    }
                }
                
                console.log('‚úÖ Todas las piezas creadas. Total:', this.pieces.length);
                
                // Eventos globales del mouse
                document.addEventListener('mousemove', (e) => this.drag(e));
                document.addEventListener('mouseup', (e) => this.endDrag(e));
                
                                    this.startTimer();
                    
                    // Llamar callback de inicio exitoso
                    if (this.onGameStarted) {
                        this.onGameStarted();
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error al crear el tablero:', error);
                    this.showStatus('‚ùå Error al crear el tablero: ' + error.message);
                    this.isPlaying = false;
                }
            }

            isPositionTooClose(x, y, pieceSize) {
                // Verificar que no est√© muy cerca de otras posiciones ya ocupadas
                for (let piece of this.pieces) {
                    const pieceX = parseFloat(piece.style.left);
                    const pieceY = parseFloat(piece.style.top);
                    const distance = Math.sqrt(Math.pow(x - pieceX, 2) + Math.pow(y - pieceY, 2));
                    if (distance < pieceSize * 0.8) {
                        return true; // Muy cerca
                    }
                }
                return false;
            }

            // M√©todo mejorado para generar posiciones aleatorias sin bucle infinito
            generateRandomPosition(pieceSize, maxAttempts = 100) {
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    const randomX = Math.random() * (400 - pieceSize);
                    const randomY = Math.random() * (400 - pieceSize);
                    
                    if (!this.isPositionTooClose(randomX, randomY, pieceSize)) {
                        return { x: randomX, y: randomY };
                    }
                }
                
                // Si no se encuentra una posici√≥n despu√©s de muchos intentos, usar una posici√≥n aleatoria
                console.warn('No se pudo encontrar posici√≥n √≥ptima, usando posici√≥n aleatoria');
                return {
                    x: Math.random() * (400 - pieceSize),
                    y: Math.random() * (400 - pieceSize)
                };
            }

            startDrag(e, piece) {
                if (!this.isPlaying) return;
                
                this.isDragging = true;
                this.draggedPiece = piece;
                piece.style.cursor = 'grabbing';
                piece.style.zIndex = '1000';
                piece.style.boxShadow = '0 8px 25px rgba(255, 20, 147, 0.4)';
                
                const rect = piece.getBoundingClientRect();
                this.dragOffset.x = e.clientX - rect.left;
                this.dragOffset.y = e.clientY - rect.top;
                
                e.preventDefault();
            }

            drag(e) {
                if (!this.isDragging || !this.draggedPiece) return;
                
                const board = document.getElementById('puzzleBoard');
                const boardRect = board.getBoundingClientRect();
                
                let newX = e.clientX - boardRect.left - this.dragOffset.x;
                let newY = e.clientY - boardRect.top - this.dragOffset.y;
                
                // Limitar al √°rea del tablero
                const pieceSize = 400 / this.difficulty;
                newX = Math.max(0, Math.min(newX, 400 - pieceSize));
                newY = Math.max(0, Math.min(newY, 400 - pieceSize));
                
                this.draggedPiece.style.left = newX + 'px';
                this.draggedPiece.style.top = newY + 'px';
                
                // Actualizar datos de posici√≥n
                this.draggedPiece.dataset.currentX = newX;
                this.draggedPiece.dataset.currentY = newY;
            }

            endDrag(e) {
                if (!this.isDragging || !this.draggedPiece) return;
                
                this.isDragging = false;
                this.draggedPiece.style.cursor = 'grab';
                this.draggedPiece.style.zIndex = 'auto';
                this.draggedPiece.style.boxShadow = '0 2px 10px rgba(255, 20, 147, 0.3)';
                
                // Verificar si la pieza est√° en su posici√≥n correcta
                this.checkPiecePosition(this.draggedPiece);
                
                this.draggedPiece = null;
                
                // Verificar si el puzzle est√° completo
                if (this.checkWin()) {
                    this.gameWon();
                }
            }

            checkPiecePosition(piece) {
                const correctX = parseInt(piece.dataset.correctX);
                const correctY = parseInt(piece.dataset.correctY);
                const currentX = parseInt(piece.dataset.currentX);
                const currentY = parseInt(piece.dataset.currentY);
                
                const pieceSize = 400 / this.difficulty;
                const tolerance = pieceSize * 0.1; // Solo 10% de tolerancia - debe estar MUY cerca
                
                if (Math.abs(currentX - correctX) < tolerance && Math.abs(currentY - correctY) < tolerance) {
                    // Pieza en posici√≥n correcta - LOCK IT!
                    piece.style.left = correctX + 'px';
                    piece.style.top = correctY + 'px';
                    piece.dataset.currentX = correctX;
                    piece.dataset.currentY = correctY;
                    piece.style.border = '3px solid #4CAF50';
                    piece.style.boxShadow = '0 6px 20px rgba(76, 175, 80, 0.6)';
                    piece.style.cursor = 'default';
                    piece.style.pointerEvents = 'none'; // Completamente inm√≥vil
                    piece.style.transform = 'scale(1.02)'; // Efecto visual
                    piece.style.transition = 'all 0.5s ease';
                    
                    // Agregar efecto de "locked"
                    piece.innerHTML = '<div style="position: absolute; top: 5px; right: 5px; color: #4CAF50; font-size: 16px; font-weight: bold;">üîí</div>';
                    
                    // Remover todos los eventos de drag
                    piece.removeEventListener('mousedown', (e) => this.startDrag(e, piece));
                    
                    this.moves++;
                    this.updateStats();
                    
                    // Efecto de celebraci√≥n
                    this.celebratePiece(piece);
                }
            }

            celebratePiece(piece) {
                // Efecto de brillo
                piece.style.filter = 'brightness(1.1)';
                setTimeout(() => {
                    piece.style.filter = 'brightness(1)';
                }, 300);
                
                // Agregar clase para animaci√≥n
                piece.classList.add('piece-locked');
            }

            checkWin() {
                return this.pieces.every(piece => {
                    const correctX = parseInt(piece.dataset.correctX);
                    const correctY = parseInt(piece.dataset.correctY);
                    const currentX = parseInt(piece.dataset.currentX);
                    const currentY = parseInt(piece.dataset.currentY);
                    
                    return Math.abs(currentX - correctX) < 5 && Math.abs(currentY - correctY) < 5;
                });
            }

            gameWon() {
                this.isPlaying = false;
                this.stopTimer();
                
                const timeElapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(timeElapsed / 60);
                const seconds = timeElapsed % 60;
                
                setTimeout(() => {
                    alert(`üéâ ¬°Puzzle completado!\n‚è±Ô∏è Tiempo: ${minutes}:${seconds.toString().padStart(2, '0')}\nüéØ Movimientos: ${this.moves}`);
                }, 100);
            }

            startTimer() {
                this.timer = setInterval(() => {
                    if (this.startTime) {
                        const timeElapsed = Math.floor((Date.now() - this.startTime) / 1000);
                        const minutes = Math.floor(timeElapsed / 60);
                        const seconds = timeElapsed % 60;
                        document.getElementById('puzzleTime').textContent = 
                            `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                }, 1000);
            }

            stopTimer() {
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
            }

            updateStats() {
                document.getElementById('puzzleMoves').textContent = this.moves;
                document.getElementById('puzzleLevel').textContent = this.difficulty;
            }

            stop() {
                this.isPlaying = false;
                this.stopTimer();
                
                // Remover eventos globales
                document.removeEventListener('mousemove', this.drag);
                document.removeEventListener('mouseup', this.endDrag);
            }
        }

        // Clase del Juego de Tiro al Blanco
        class ArcheryGame {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.score = 0;
                this.arrows = 10;
                this.lives = 3;
                this.isPlaying = false;
                this.targets = [];
                this.arrows = [];
                this.lastTime = 0;
                this.animationId = null;
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('startArcheryBtn').addEventListener('click', () => this.startGame());
            }

            startGame() {
                this.canvas = document.getElementById('archeryCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.score = 0;
                this.arrows = 10;
                this.lives = 3;
                this.isPlaying = true;
                this.targets = [];
                this.arrows = [];
                
                this.updateStats();
                this.createTargets();
                this.setupCanvasEvents();
                this.gameLoop();
            }

            createTargets() {
                this.targets = [];
                for (let i = 0; i < 5; i++) {
                    this.targets.push({
                        x: Math.random() * (this.canvas.width - 100) + 50,
                        y: Math.random() * (this.canvas.height - 100) + 50,
                        size: 30 + Math.random() * 20,
                        type: Math.random() > 0.7 ? 'heart' : 'circle',
                        points: Math.random() > 0.7 ? 20 : 10
                    });
                }
            }

            setupCanvasEvents() {
                this.canvas.addEventListener('click', (e) => this.shootArrow(e));
            }

            shootArrow(e) {
                if (!this.isPlaying || this.arrows <= 0) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.arrows--;
                this.updateStats();
                
                // Crear flecha
                this.arrows.push({
                    x: this.canvas.width / 2,
                    y: this.canvas.height - 50,
                    targetX: x,
                    targetY: y,
                    speed: 15
                });
                
                if (this.arrows <= 0) {
                    setTimeout(() => this.endGame(), 2000);
                }
            }

            gameLoop(currentTime = 0) {
                if (!this.isPlaying) return;
                
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.draw();
                
                this.animationId = requestAnimationFrame((time) => this.gameLoop(time));
            }

            update(deltaTime) {
                // Actualizar flechas
                for (let i = this.arrows.length - 1; i >= 0; i--) {
                    const arrow = this.arrows[i];
                    const dx = arrow.targetX - arrow.x;
                    const dy = arrow.targetY - arrow.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < arrow.speed) {
                        // Flecha lleg√≥ al objetivo
                        this.checkHit(arrow.targetX, arrow.targetY);
                        this.arrows.splice(i, 1);
                    } else {
                        arrow.x += (dx / distance) * arrow.speed;
                        arrow.y += (dy / distance) * arrow.speed;
                    }
                }
                
                // Mover objetivos
                this.targets.forEach(target => {
                    target.y += 0.5;
                    if (target.y > this.canvas.height + 50) {
                        target.y = -50;
                        target.x = Math.random() * (this.canvas.width - 100) + 50;
                    }
                });
            }

            checkHit(x, y) {
                for (let i = this.targets.length - 1; i >= 0; i--) {
                    const target = this.targets[i];
                    const distance = Math.sqrt(
                        Math.pow(x - target.x, 2) + Math.pow(y - target.y, 2)
                    );
                    
                    if (distance < target.size) {
                        this.score += target.points;
                        this.targets.splice(i, 1);
                        this.updateStats();
                        
                        // Crear nuevo objetivo
                        if (this.targets.length < 5) {
                            this.targets.push({
                                x: Math.random() * (this.canvas.width - 100) + 50,
                                y: -50,
                                size: 30 + Math.random() * 20,
                                type: Math.random() > 0.7 ? 'heart' : 'circle',
                                points: Math.random() > 0.7 ? 20 : 10
                            });
                        }
                        break;
                    }
                }
            }

            draw() {
                // Limpiar canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Dibujar fondo
                this.ctx.fillStyle = '#ffe6f2';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Dibujar objetivos
                this.targets.forEach(target => {
                    if (target.type === 'heart') {
                        this.drawHeart(target.x, target.y, target.size, '#ff1493');
                    } else {
                        this.ctx.fillStyle = '#ff69b4';
                        this.ctx.beginPath();
                        this.ctx.arc(target.x, target.y, target.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
                
                // Dibujar flechas
                this.ctx.strokeStyle = '#8b4513';
                this.ctx.lineWidth = 3;
                this.arrows.forEach(arrow => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(arrow.x, arrow.y);
                    this.ctx.lineTo(arrow.x - 10, arrow.y - 5);
                    this.ctx.stroke();
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(arrow.x, arrow.y);
                    this.ctx.lineTo(arrow.x + 10, arrow.y - 5);
                    this.ctx.stroke();
                });
                
                // Dibujar arco
                this.ctx.strokeStyle = '#8b4513';
                this.ctx.lineWidth = 5;
                this.ctx.beginPath();
                this.ctx.arc(this.canvas.width / 2, this.canvas.height - 30, 20, 0, Math.PI);
                this.ctx.stroke();
            }

            drawHeart(x, y, size, color) {
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y + size * 0.3);
                this.ctx.bezierCurveTo(x, y, x - size, y, x - size, y + size * 0.3);
                this.ctx.bezierCurveTo(x - size, y + size * 0.6, x, y + size * 0.8, x, y + size * 0.8);
                this.ctx.bezierCurveTo(x, y + size * 0.8, x + size, y + size * 0.6, x + size, y + size * 0.3);
                this.ctx.bezierCurveTo(x + size, y, x, y, x, y + size * 0.3);
                this.ctx.fill();
            }

            updateStats() {
                document.getElementById('archeryScore').textContent = this.score;
                document.getElementById('archeryArrows').textContent = this.arrows;
                document.getElementById('archeryLives').textContent = this.lives;
            }

            endGame() {
                this.isPlaying = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                
                setTimeout(() => {
                    alert(`üéØ ¬°Juego terminado!\nüèÜ Puntuaci√≥n: ${this.score} puntos\nüèπ Flechas restantes: ${this.arrows}`);
                }, 100);
            }

            stop() {
                this.isPlaying = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
        }

        // Inicializar part√≠culas
        function createParticles() {
            const particlesContainer = document.getElementById('particles');
            const particleCount = 50;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 3 + 's';
                particle.style.animationDuration = (Math.random() * 2 + 2) + 's';
                particlesContainer.appendChild(particle);
            }
        }

        // Inicializar cuando cargue la p√°gina
        window.onload = function() {
            createParticles();
        };
    </script>

    <!-- ---------FOOTER-------- -->
    <section id="contactos">
        <footer class="fin">
            <p>Para Mavi con todo mi amor</p>
            <p>Te amo m√°s que ayer pero menos que ma√±ana üíï</p>
        </footer>  
    </section>
</body>
</html>